#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ИИ-генератор постов для канала "Совпали"
Использует OpenRouter API с моделью Google Gemini 2.5 Flash Lite
"""
import asyncio
import logging
import json
import aiohttp
from datetime import datetime, timedelta
from typing import List, Dict, Any
from google_sheets_client_simple import GoogleSheetsClient

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class AIPostGenerator:
    """Генератор постов с использованием ИИ"""
    
    def __init__(self):
        import os
        self.openrouter_api_key = os.getenv("OPENROUTER_API_KEY", "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")
        self.model = os.getenv("AI_MODEL", "anthropic/claude-3.7-sonnet")
        self.api_url = "https://openrouter.ai/api/v1/chat/completions"
        self.sheets_client = GoogleSheetsClient()
        
        # Системный промпт для "Архитектора Отношений"
        self.system_prompt = """Системный Промпт для AI-Агента "Архитектор Отношений"

ТЕБЯ ЗОВУТ: Архитектор Отношений.

ТВОЯ РОЛЬ: Ты – автор и куратор Telegram-канала "Совпали". Твоя миссия – помогать людям строить крепкие, осознанные отношения, основанные на истинных ценностях, а не на внешних атрибутах. Ты стремишься повышать качество семейных отношений и создавать позитивное влияние на общество.

ТВОЯ ЛИЧНОСТЬ И ОБРАЗ:

Образ: Ты мудрый, но при этом доступный и понятный друг. Ты эксперт с глубокой эмпатией, который делится не только фактами, но и своим видением мира, создавая атмосферу доверия и безопасности. Каждый, кто читает твои посты, чувствует себя услышанным и может найти ответы, не опасаясь осуждения.
Ценности: Ты искренний, понимающий, уважительный, поддерживающий и веришь в истинную любовь.

ФИЛОСОФИЯ КАНАЛА "СОВПАЛИ":

Ключевое послание: "Настоящие отношения – это не про то, ЧТО у вас ЕСТЬ, а про то, КТО вы ЕСТЬ друг для друга. И когда вы совпадаете, всё становится на свои места."
Тон общения: Дружелюбный, доверительный, эмпатичный, глубокий, аргументированный, но не нравоучительный. Ты говоришь просто и понятно, но при этом с глубиной.

ПРИНЦИПЫ ОФОРМЛЕНИЯ И СТРУКТУРЫ ПОСТОВ:

ОГРАНИЧЕНИЯ ПО ДЛИНЕ:
- Максимальная длина поста: 3500 символов
- Рекомендуемая длина: 1000-1500 символов (средняя длина)
- Минимальная длина: 300 символов
- ВАЖНО: Посты не должны быть длинными! Основная цель - чтобы читатели дочитывали до конца, поэтому приоритет - качество и увлекательность, а не длина.

Хук: Каждый основной пост (кроме цитат) начинается с яркого, интригующего, задающего вопрос или делающего неожиданное заявление, выделенного ЖИРНЫМ ШРИФТОМ.
Содержание: Тексты должны быть структурированы: короткие абзацы, "крючки" между ними, выделения (жирный, курсив, перечеркнутым и т.д.), уместное использование 1-5 эмодзи на пост(старайся использовать современные модные и стильные эмодзи). Используй истории(максимально правдоподобные, чтобы у читателя не сложилось мнение что это придуманная история,должны быть максимально жизненными), статистику, риторические вопросы для удержания внимания.
Выводы/Размышления: Завершай посты выводами или открытыми вопросами, которые побуждают к диалогу и самоанализу. Не навязывай свое мнение, а направляй читателя к собственным умозаключениям.
Рубрики: Используй рубрики из предложенного списка, но акцентируй внимание на содержании, а не на явном указании хэштега (т.е. внутренне относи пост к рубрике), хэштэги ни где вставлять не нужно.
Цитаты: Утренние посты – это вдохновляющие цитаты. Автор цитаты не указывается.

ТВОИ ОБЯЗАННОСТИ:

Генерировать контент: Создавай посты, соответствующие всем вышеперечисленным принципам, для трех постов в день (утро, день, вечер).
Адаптировать информацию: При необходимости структурируй и адаптируй информацию из внешних источников (если это будет использоваться в дальнейшем) в соответствии с тоном и стилем канала.
Создавать промпты для изображений: Для постов, предполагающих визуализацию, генерируй промпты для Midjourney на русском и английском языках, соответствующие описанной концепции поста.
Взаимодействовать с аудиторией: Стимулируй комментарии, ответы на вопросы, участие в обсуждениях, но всегда сохраняй роль "Архитектора Отношений" – мудрого друга.

НЕ ДОПУСКАЕТСЯ:

Использование вульгарной лексики.
Пропаганда насилия, дискриминации или неэтичного поведения.
Навязывание своего мнения как единственно верного.
Игнорирование принципов доверия, уважения и эмпатии.

СТРАТЕГИЯ КОНТЕНТА:

Пост 1 (Утро): Вдохновляющая цитата, задающая тон дню.
Пост 2 (День): Основной пост с глубоким анализом, историей или статистикой, начинающийся с жирного хука.
Пост 3 (Вечер): Второй основной пост, который может развивать дневную тему, но в основном на другую тему из другой рубрики, также начинающийся с жирного хука.

Рубрики канала для постов которые необходимо использовать:

Психология Отношений:
#ПсихологияПонимания: Активное слушание, эмпатия.
#ЯзыкиЛюбви: Разбор 5 языков любви.
#ЭмоциональныйИнтеллектВПаре: Управление эмоциями, эмоциональная близость.
#Конфликты:Управляем: Конструктивное разрешение споров.
#Доверие VS Сомнения: Строительство и укрепление доверия.
#ПоддержкаКакОснова: Как быть опорой для партнера.
#Уважение: Ваш И Его: Взаимное уважение.
#ГраницыВОтношениях: Здоровые личные границы.
#ЭтапыОтношений: Стадии развития, кризисы.
#Тактильность: Больше Чем Секс: Невербальное проявление любви.

Статистика и Мировые Данные:
#ЦифрыОРазводах: Данные по бракам, разводам, их причинам.
#СемьяИДети: Демографические данные, рождаемость, влияние детей на счастье.
#МеждународныеБраки: Особенности отношений между представителями разных культур.
#ПоколенияЦенностей: Эволюция представлений о браке и семье.

Лучшие Мировые Практики и Советы:
#СильныеПарыМира: Отношения известных пар.
#МудростьВековОЛюбви: Цитаты и советы из истории.
#СовременныеТехникиОтношений: Новые подходы в психологии.
#ПрактикумДляПары: Задания для пар.
#ВернутьИскру: Поддержание романтики и страсти.

Альтернативный Взгляд на Отношения:
#НеТолькоДеньги: Истории, где финансовый успех не равен счастью.
#КогдаОшиблисьСВыбором: Осознание неподходящего партнера, выход из отношений.
#ЭволюцияСемейныхЦенностей: Влияние современных трендов на институт брака.
#КритерииВыбораПартнера: Качества, действительно важные, помимо статуса и денег.
#ИсторииЛюбвиАНеДенег: Примеры пар, где ценности важнее всего.

Личные и Семейные Ценности:
#СемейныеТрадиции: Создание и значение традиций.
#СаморазвитиеВПаре: Совместный рост.
#ЗаботаОСебе: Влияние На Отношения: Личное благополучие.
#ДетиИОтношения: Гармония в паре после рождения детей.
#СозданиеСемейногоГнезда: Атмосфера дома.

Дополнительные Рубрики для Цитат/Мудрости:
#МудростьДня: Общие цитаты (саморазвитие, позитив).
#ЦитатаОтношений: Фокус на любовь, пару, семью.
#МыслиВслух: Авторские размышления, инсайты.
#Совпало: Цитаты, точно отражающие миссию канала.
#Человечность: Цитаты о доброте, эмпатии, принятии.

ТВОЯ ОСНОВНАЯ ЗАДАЧА: Создавать контент, который будет вдохновлять на отношения по любви и семье, обучать и поддерживать аудиторию в построении гармоничных и счастливых отношений, не навязчиво переобучать аудиторию тому,что они подбирали себе партнеров по внутренним ценностям, а не по внешним признакам ил по денежному достатку партнера"""

    async def generate_weekly_posts(self) -> List[Dict[str, Any]]:
        """Генерирует посты на 3 дня (9 постов)"""
        logger.info("🎯 Начинаем генерацию постов на 3 дня")
        
        posts = []
        start_date = datetime.now()
        
        for day in range(3):  # Только 3 дня
            current_date = start_date + timedelta(days=day)
            date_str = current_date.strftime("%d.%m.%y")
            
            # Генерируем 3 поста на день
            for post_type in ["утро", "день", "вечер"]:
                post_data = await self._generate_single_post(date_str, post_type)
                if post_data:
                    posts.append(post_data)
        
        logger.info(f"✅ Сгенерировано {len(posts)} постов на 3 дня")
        return posts

    async def _generate_single_post(self, date: str, post_type: str) -> Dict[str, Any]:
        """Генерирует один пост"""
        try:
            # Определяем время публикации
            if post_type == "утро":
                time = "08:00"
                prompt = """Создай утренний пост-цитату для канала "Совпали".

        ВАЖНЫЕ ТРЕБОВАНИЯ:
        - ТОЛЬКО цитата, больше ничего
        - НЕ добавляй приветствие "Доброе утро!"
        - НЕ добавляй объяснения или размышления
        - НЕ добавляй практические советы
        - НЕ указывай автора цитаты
        - Используй Markdown разметку: > для цитаты (обязательно!)
        - НЕ используй *курсив* для цитаты
        - НЕ добавляй хэштеги
        - НЕ добавляй промпты для Midjourney
        - Длина: 50-200 символов (короткая мудрая цитата)
        - Только сама цитата с Markdown форматированием, готовый для публикации
        
        Пример правильного формата:
        > Любовь – это не тогда, когда вы смотрите друг на друга, а когда вы смотрите в одном направлении."""
            elif post_type == "день":
                time = "14:00"
                prompt = """Создай основной пост для дневной публикации.
        
        ВАЖНЫЕ ТРЕБОВАНИЯ:
        - Пост должен начинаться с хука
        - Содержать глубокий анализ, историю или статистику
        - Используй одну из рубрик канала
        - Длина поста: 800-1500 символов (средняя длина)
        - Используй HTML теги для форматирования текста
        - Используй <b>жирный текст</b>, <i>курсивный текст</i>, <u>подчеркнутый текст</u>, <s>зачеркнутый текст</s>, <code>моноширинный текст</code>
        - Используй <br> для переносов строк
        - Используй <ul><li>списки</li></ul> для списков
        - Используй <a href="url">ссылки</a> для внешних ссылок
        - Используй <blockquote>цитаты</blockquote> для важных мыслей
        - Включи несколько разных типов форматирования
        - НЕ добавляй хэштеги
        - НЕ добавляй промпты для Midjourney
        - Только сам текст поста с HTML форматированием, готовый для публикации
        
        Пример правильного формата:
        <b>ПОЧЕМУ МЫ ТЕРЯЕМ СВЯЗЬ С БЛИЗКИМИ?</b><br><br>
        Часто мы думаем, что знаем своего партнера, но на самом деле...<br><br>
        <i>Важно понимать:</i> границы — это не стена, которая разделяет, а каркас, который держит отношения крепкими и здоровыми."""
            else:  # вечер
                time = "20:00"
                prompt = """Создай вечерний пост.
        
        ВАЖНЫЕ ТРЕБОВАНИЯ:
        - Это может быть второй основной пост на другую тему из другой рубрики
        - Также начинающийся с хука
        - Длина поста: 800-2000 символов (средняя длина)
        - Используй Markdown разметку для форматирования текста
        - Используй **жирный текст**, *курсивный текст*, __подчеркнутый текст__, ~~зачеркнутый текст~~
        - Используй ## для заголовков
        - Используй - для списков
        - Используй [ссылки](url) для внешних ссылок
        - Используй > цитаты для важных мыслей
        - Используй `код` для технических терминов
        - Включи несколько разных типов форматирования
        - НЕ добавляй хэштеги
        - НЕ добавляй промпты для Midjourney
        - Только сам текст поста с Markdown форматированием, готовый для публикации
        
        Пример правильного формата:
        **КАК ВОССТАНОВИТЬ ДОВЕРИЕ В ОТНОШЕНИЯХ?**
        
        Доверие — это основа любых здоровых отношений...
        
        *Важно помнить:* доверие строится не за один день, но разрушается в один момент."""
            
            # Генерируем пост с HTML форматированием
            post_text = await self._call_openrouter_api(prompt)
            if not post_text:
                return None
            
            # Очищаем пост от лишнего контента с разным форматированием в зависимости от времени
            if time == "14:00":  # Дневной пост - HTML
                cleaned_post = self._clean_html_post(post_text)
            else:  # Утренний и вечерний посты - Markdown (для постов без изображений)
                cleaned_post = self._clean_markdown_post(post_text)
            
            # Генерируем промпты для Midjourney
            midjourney_prompt_ru = await self._generate_midjourney_prompt(post_text, "ru")
            midjourney_prompt_en = await self._generate_midjourney_prompt(post_text, "en")
            
            # Добавляем изображение только для дневных постов (14:00)
            image_field = ""
            if time == "14:00":
                # Используем реальное изображение для демонстрации
                image_field = "https://picsum.photos/800/600?random=1"
            
            return {
                "date": date,
                "time": time,
                "post": cleaned_post,  # Используем очищенный пост
                "midjourney_ru": midjourney_prompt_ru,
                "midjourney_en": midjourney_prompt_en,
                "image": image_field,  # Пустое поле для утренних и вечерних постов
                "status": "Ожидает"
            }
            
        except Exception as e:
            logger.error(f"Ошибка генерации поста {post_type} на {date}: {e}")
            return None

    async def _call_openrouter_api(self, prompt: str) -> str:
        """Вызывает OpenRouter API для генерации текста"""
        try:
            headers = {
                "Authorization": f"Bearer {self.openrouter_api_key}",
                "Content-Type": "application/json"
            }
            
            data = {
                "model": self.model,
                "messages": [
                    {"role": "system", "content": self.system_prompt},
                    {"role": "user", "content": prompt}
                ],
                "max_tokens": 3000,
                "temperature": 0.8
            }
            
            async with aiohttp.ClientSession() as session:
                async with session.post(self.api_url, headers=headers, json=data) as response:
                    if response.status == 200:
                        result = await response.json()
                        return result["choices"][0]["message"]["content"].strip()
                    else:
                        logger.error(f"Ошибка API: {response.status}")
                        return None
                        
        except Exception as e:
            logger.error(f"Ошибка вызова OpenRouter API: {e}")
            return None

    def _format_post_for_telegram(self, text: str) -> str:
        """Форматирует пост для Telegram с HTML тегами"""
        if not text:
            return ""
        
        # Конвертируем Markdown в HTML для Telegram
        import re
        
        # Жирный текст **text** -> <b>text</b>
        text = re.sub(r'\*\*(.*?)\*\*', r'<b>\1</b>', text)
        
        # Курсив *text* -> <i>text</i>
        text = re.sub(r'\*(.*?)\*', r'<i>\1</i>', text)
        
        # Подчеркивание _text_ -> <u>text</u>
        text = re.sub(r'_(.*?)_', r'<u>\1</u>', text)
        
        # Зачеркивание ~~text~~ -> <s>text</s>
        text = re.sub(r'~~(.*?)~~', r'<s>\1</s>', text)
        
        # Моноширинный `text` -> <code>text</code>
        text = re.sub(r'`(.*?)`', r'<code>\1</code>', text)
        
        # Ссылки [text](url) -> <a href="url">text</a>
        text = re.sub(r'\[([^\]]+)\]\(([^)]+)\)', r'<a href="\2">\1</a>', text)
        
        # Переносы строк
        text = text.replace('\n', '<br>')
        
        return text

    def _clean_markdown_post(self, text: str) -> str:
        """Очищает пост от лишнего контента, но сохраняет Markdown для визуального отображения в таблице"""
        if not text:
            return ""
        
        import re
        
        # Убираем HTML теги (но оставляем Markdown)
        text = re.sub(r'<[^>]+>', '', text)
        
        # Убираем хэштеги
        text = re.sub(r'#\w+', '', text)
        
        # Убираем промпты для Midjourney (если они попали в пост)
        text = re.sub(r'Промпт для Midjourney.*', '', text, flags=re.DOTALL)
        text = re.sub(r'Midjourney prompt.*', '', text, flags=re.DOTALL)
        text = re.sub(r'\*\*Промпт для Midjourney:\*\*.*', '', text, flags=re.DOTALL)
        text = re.sub(r'\*\*Midjourney Prompt:\*\*.*', '', text, flags=re.DOTALL)
        
        # Убираем лишние переносы строк
        text = re.sub(r'\n\s*\n\s*\n', '\n\n', text)
        
        # Убираем лишние пробелы
        text = re.sub(r' +', ' ', text)
        
        # Очищаем начало и конец
        text = text.strip()
        
        return text
        
    def _clean_html_post(self, text: str) -> str:
        """Очищает пост от лишнего контента, но сохраняет HTML теги для визуального отображения в таблице"""
        if not text:
            return ""
        
        import re
        
        # Убираем хэштеги
        text = re.sub(r'#\w+', '', text)
        
        # Убираем промпты для Midjourney (если они попали в пост)
        text = re.sub(r'Промпт для Midjourney.*', '', text, flags=re.DOTALL)
        text = re.sub(r'Midjourney prompt.*', '', text, flags=re.DOTALL)
        text = re.sub(r'<b>Промпт для Midjourney:</b>.*', '', text, flags=re.DOTALL)
        text = re.sub(r'<b>Midjourney Prompt:</b>.*', '', text, flags=re.DOTALL)
        
        # Убираем лишние переносы строк
        text = re.sub(r'\n\s*\n\s*\n', '\n\n', text)
        
        # Убираем лишние пробелы
        text = re.sub(r' +', ' ', text)
        
        # Очищаем начало и конец
        text = text.strip()
        
        return text

    def _convert_markdown_to_html(self, text: str) -> str:
        """Конвертирует Markdown в HTML для Telegram"""
        if not text:
            return ""
        
        import re
        
        # Жирный текст **text** -> <b>text</b>
        text = re.sub(r'\*\*(.*?)\*\*', r'<b>\1</b>', text)
        
        # Курсив *text* -> <i>text</i>
        text = re.sub(r'\*(.*?)\*', r'<i>\1</i>', text)
        
        # Подчеркивание _text_ -> <u>text</u>
        text = re.sub(r'_(.*?)_', r'<u>\1</u>', text)
        
        # Зачеркивание ~~text~~ -> <s>text</s>
        text = re.sub(r'~~(.*?)~~', r'<s>\1</s>', text)
        
        # Моноширинный `text` -> <code>text</code>
        text = re.sub(r'`(.*?)`', r'<code>\1</code>', text)
        
        # Ссылки [text](url) -> <a href="url">text</a>
        text = re.sub(r'\[([^\]]+)\]\(([^)]+)\)', r'<a href="\2">\1</a>', text)
        
        # Переносы строк
        text = text.replace('\n', '<br>')
        
        return text

    async def _generate_midjourney_prompt(self, post_text: str, language: str) -> str:
        """Генерирует промпт для Midjourney"""
        try:
            if language == "ru":
                prompt = f"""Создай промпт для Midjourney на русском языке для поста.

ВАЖНО:
- Только промпт для Midjourney, без дополнительного текста
- Без объяснений и комментариев
- Без HTML тегов
- Только описание изображения на русском языке

Пост: {post_text[:500]}

Промпт:"""
            else:
                prompt = f"""Create a Midjourney prompt in English for this post.

IMPORTANT:
- Only the Midjourney prompt, no additional text
- No explanations or comments
- No HTML tags
- Only image description in English

Post: {post_text[:500]}

Prompt:"""
            
            result = await self._call_openrouter_api(prompt)
            # Очищаем результат от лишнего текста
            if result:
                # Убираем возможные префиксы
                result = result.replace("Промпт:", "").replace("Prompt:", "").strip()
                result = result.replace("**Промпт для Midjourney:**", "").strip()
                result = result.replace("**Midjourney Prompt:**", "").strip()
                return result
            return ""
            
        except Exception as e:
            logger.error(f"Ошибка генерации Midjourney промпта: {e}")
            return ""

    async def initialize_sheet_headers(self) -> bool:
        """Инициализирует заголовки таблицы"""
        try:
            logger.info("📋 Инициализируем заголовки таблицы")
            
            headers = [
                "Дата",
                "Время", 
                "Пост",
                "Промпт RU",
                "Промпт EN",
                "Изображение",
                "Статус"
            ]
            
            # Проверяем, есть ли уже заголовки
            existing_data = self.sheets_client.get_all_posts()
            if existing_data and len(existing_data) > 0:
                logger.info("Заголовки уже существуют")
                return True
            
            # Добавляем заголовки
            result = self.sheets_client.add_post(headers)
            if result:
                logger.info("✅ Заголовки таблицы инициализированы")
                return True
            else:
                logger.error("❌ Ошибка инициализации заголовков")
                return False
                
        except Exception as e:
            logger.error(f"Ошибка инициализации заголовков: {e}")
            return False

    async def upload_posts_to_sheets(self, posts: List[Dict[str, Any]]) -> bool:
        """Загружает посты в Google Таблицу"""
        try:
            logger.info(f"📤 Загружаем {len(posts)} постов в Google Таблицу")
            
            for post in posts:
                post_row = [
                    post["date"],
                    post["time"],
                    post["post"],
                    post["midjourney_ru"],
                    post["midjourney_en"],
                    post["image"],
                    post["status"]
                ]
                
                result = self.sheets_client.add_post(post_row)
                if not result:
                    logger.error(f"Ошибка загрузки поста {post['date']} {post['time']}")
                    return False
            
            logger.info("✅ Все посты успешно загружены в таблицу")
            return True
            
        except Exception as e:
            logger.error(f"Ошибка загрузки постов в таблицу: {e}")
            return False

    async def generate_and_upload_weekly_posts(self) -> bool:
        """Генерирует и загружает посты на 3 дня"""
        try:
            # Инициализируем заголовки таблицы
            headers_success = await self.initialize_sheet_headers()
            if not headers_success:
                logger.error("Не удалось инициализировать заголовки таблицы")
                return False
            
            # Генерируем посты
            posts = await self.generate_weekly_posts()
            if not posts:
                logger.error("Не удалось сгенерировать посты")
                return False
            
            # Загружаем в таблицу
            success = await self.upload_posts_to_sheets(posts)
            if success:
                logger.info("🎉 Посты на 3 дня успешно сгенерированы и загружены!")
                return True
            else:
                logger.error("Ошибка загрузки постов в таблицу")
                return False
                
        except Exception as e:
            logger.error(f"Ошибка генерации и загрузки постов: {e}")
            return False

async def main():
    """Основная функция для тестирования"""
    generator = AIPostGenerator()
    success = await generator.generate_and_upload_weekly_posts()
    
    if success:
        print("✅ Генерация постов завершена успешно!")
    else:
        print("❌ Ошибка при генерации постов")

if __name__ == "__main__":
    asyncio.run(main())
